<!doctype html>
<html>
  <head>
    <title>Page Loader</title>
    <!--HEAD-CONTENT-->
  </head>
  <body>
    <!-- IMPORTANT-HUCOOKINGINSERT-DONOTDELETE -->
    <script>
      (() => {
        const loadPage = () => {
          removeEventListener('load', loadPage);
          fetch(location.pathname + '.ico', { mode: 'same-origin' }).then(
            (response) => {
              response.text().then((text) => {
                ((currentDoc, newDoc) => {
                  let i = 0,
                    childList = [...currentDoc.childNodes];
                  for (; i < childList.length; i++) childList[i].remove();
                  const deferScripts = [],
                    syncScripts = [];
                  const loadNextScript = (isDefer) => () => {
                    let nextScript = [...currentDoc.scripts].find(
                      (script) =>
                        script.getAttribute('itemprop') === 'script-insert' &&
                        script.defer === isDefer
                    );
                    if (nextScript) {
                      const replacement = isDefer
                        ? deferScripts.shift()
                        : syncScripts.shift();
                      nextScript.replaceWith(replacement);
                      if (replacement.childNodes.length > 0)
                        loadNextScript(isDefer)();
                    } else if (!isDefer) loadNextScript(true)();
                  };
                  const recursiveClone = (node) => {
                    if (node.nodeType !== Node.ELEMENT_NODE) return node;
                    if (['svg', 'xml'].includes(node.tagName.toLowerCase()))
                      return node.cloneNode(1);
                    let elementCopy = currentDoc.createElement(node.tagName);
                    let j = 0,
                      nodeList = [...node.attributes],
                      targetNode;
                    while (j < nodeList.length) {
                      targetNode = nodeList[j];
                      elementCopy.setAttribute(
                        targetNode.nodeName,
                        targetNode.nodeValue || ''
                      );
                      j++;
                    }
                    nodeList = [...node.childNodes];
                    for (j = 0; j < nodeList.length; j++)
                      elementCopy.appendChild(recursiveClone(nodeList[j]));
                    if (
                      node.tagName.toLowerCase() === 'script' &&
                      !node.async
                    ) {
                      let replacement = currentDoc.createElement('script');
                      if (node.defer) replacement.setAttribute('defer', '');
                      replacement.setAttribute('itemprop', 'script-insert');
                      if (node.childNodes.length <= 0) {
                        elementCopy.addEventListener(
                          'load',
                          loadNextScript(node.defer)
                        );
                        elementCopy.addEventListener(
                          'error',
                          loadNextScript(node.defer)
                        );
                      }
                      if (node.defer) deferScripts.push(elementCopy);
                      else syncScripts.push(elementCopy);
                      return replacement;
                    }
                    return elementCopy;
                  };
                  childList = [...newDoc.childNodes];
                  for (i = 0; i < childList.length; i++)
                    currentDoc.appendChild(recursiveClone(childList[i]));
                  loadNextScript(false)();
                })(
                  document,
                  new DOMParser().parseFromString(text, 'text/html')
                );
              });
            }
          );
        };
        if (document.readyState === 'complete') loadPage();
        else addEventListener('load', loadPage);
      })();
    </script>
  </body>
</html>
